### 设计模式
> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。

###### 创建型 (Creational)
主要用于描述如何创建对象

* 单例模式 (Singleton Pattern)

> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法. (为了防止在外部对其实例化，将其构造函数设计为私有。)

主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；
其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。

适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点

* 简单工厂模式 (Simple Factory Pattern)

> 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式。它属于类创建型模式。

* 工厂方法模式 (Factory Method Pattern)

> 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。它属于类创建型模式。

包含四个角色：抽象产品/具体产品/抽象工厂/具体工厂

主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；
其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

* 抽象工厂模式 (Abstract Factory Pattern)

> 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

四个角色: 抽象工厂/具体工厂/抽象产品/具体产品

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；
主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

* 原型模式 (Prototype Pattern)

> 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。

三个角色: 抽象原型类/具体原型类/客户类

主要优点是简化复杂对象的创建过程，扩展性较好，还可以使用深克隆的方式保存对象状态，在需要的时候使用可辅助实现撤销操作。
主要缺点是需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了 “ 开闭原则 ”；在实现深克隆时需要编写较为复杂的代码。

适用情况包括：创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得；如果系统要保存对象的状态；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态。

* 建造者模式 (Builder Pattern)

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。

四个角色: 抽象建造者/具体建造者/产品角色/指挥者
指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程

主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；
主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。

###### 结构型 (Structural)
主要用于描述如何实现类或对象的组合

* 适配器模式 (Adapter Pattern)

* 桥接模式 (Bridge Pattern)

* 组合模式 (Composite Pattern)

* 装饰模式 (Decorator Pattern)

* 外观模式 (Facade Pattern)

* 享元模式 (Flyweight Pattern)

* 代理模式 (Proxy Pattern)

###### 行为型 (Behavioral)
主要用于描述类或对象怎样交互以及怎样分配职责

* 职责链模式 (Chain of Responsibility Pattern)

* 命令模式 (Command Pattern)

* 解释器模式 (Interpreter Pattern)

* 迭代器模式 (Iterator Pattern)

* 中介者模式 (Mediator Pattern)

* 备忘录模式 (Memento Pattern)

* 观察者模式 (Observer Pattern)

* 状态模式 (State Pattern)

* 策略模式 (Strategy Pattern)

* 模板方法模式 (Template Pattern)

* 访问者模式 (Visitor Pattern)

##### 设计原则

* 单一职责原则 (Single Responsibility Principle, SRP)

* 开闭原则 (Open-Closed Principle)

* 里氏代换原则 (Liskov Substitution)

* 依赖倒换原则 (Dependence Inversion Principle, DIP)

* 接口隔离原则 (Interface Segregation Principle, ISP)

* 合成复用原则 (Composite Reuse Principle, CRP)

* 迪米特法则 (Law of Demeter, LoD)


---

[设计模式汇总](http://www.jianshu.com/p/f7f9553ba2ba?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
